diff --git a/utils/v4l2loopback-ctl b/utils/v4l2loopback-ctl
index 2054e46..58528b0 100755
--- a/utils/v4l2loopback-ctl
+++ b/utils/v4l2loopback-ctl
@@ -98,11 +98,11 @@ set_caps() {
     }
     #echo "nofps_caps: $nofps_caps"
     check_application v4l2-ctl
-    check_application gst-launch-0.10
+    check_application gst-launch-1.0
 
     v4l2-ctl -d $device -c keep_format=1 || exit 1
     v4l2-ctl -d $device -c sustain_framerate=1 || exit 1
-    gst-launch-0.10 videotestsrc num-buffers=1 ! "$nofps_caps" ! v4l2sink device=$device || die "output to $device failed"
+    gst-launch-1.0 videotestsrc num-buffers=1 ! "$nofps_caps" ! v4l2sink device=$device || die "output to $device failed"
 }
 
 set_timeout_image() {
@@ -113,15 +113,15 @@ set_timeout_image() {
     [ -n "`cat $sysfs/format`" ] || die "Device has no format negotiated"
 
     check_application v4l2-ctl
-    check_application gst-launch-0.10
+    check_application gst-launch-1.0
 
     v4l2-ctl -d $device -c timeout_image_io=1
     if [ "$imagefile" = 'videotestsrc' ]; then
-        gst-launch-0.10 videotestsrc num-buffers=1 ! v4l2sink device=$device
+        gst-launch-1.0 videotestsrc num-buffers=1 ! v4l2sink device=$device
     else
         uri="file://`readlink -f $imagefile`" || die "no file"
         echo "Reading from $uri"
-        gst-launch-0.10 uridecodebin uri=$uri ! ffmpegcolorspace ! videoscale ! imagefreeze ! identity error-after=2 ! v4l2sink show-preroll-frame=false device=$device
+        gst-launch-1.0 uridecodebin uri=$uri ! videoconvert ! videoscale ! imagefreeze ! identity error-after=2 ! v4l2sink show-preroll-frame=false device=$device
     fi
     timeout=`v4l2-ctl -d $device -C timeout | sed -n 's/^timeout: //p'`
     [ -n "$timeout" ] || die "couldn't get timeout"
diff --git a/v4l2loopback.c b/v4l2loopback.c
index 9a23773..3fe6ee6 100644
--- a/v4l2loopback.c
+++ b/v4l2loopback.c
@@ -188,7 +188,7 @@ static char *card_label[MAX_DEVICES];
 module_param_array(card_label, charp, NULL, 0000);
 MODULE_PARM_DESC(card_label, "card labels for every device");
 
-static bool exclusive_caps[MAX_DEVICES] = { [0 ... (MAX_DEVICES - 1)] = 1 };
+static bool exclusive_caps[MAX_DEVICES] = { [0 ... (MAX_DEVICES - 1)] = 0 };
 module_param_array(exclusive_caps, bool, NULL, 0444);
 /* FIXXME: wording */
 MODULE_PARM_DESC(exclusive_caps, "whether to announce OUTPUT/CAPTURE capabilities exclusively or not");
@@ -625,6 +625,15 @@ static inline void unset_flags(struct v4l2l_buffer *buffer)
 	buffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;
 }
 
+static void vidioc_fill_name(char *buf, int len, int nr)
+{
+	if (card_label[nr] != NULL) {
+		snprintf(buf, len, card_label[nr]);
+	} else {
+		snprintf(buf, len, "Dummy video device (0x%04X)", nr);
+	}
+}
+
 /* V4L2 ioctl caps and params calls */
 /* returns device capabilities
  * called on VIDIOC_QUERYCAP
@@ -636,11 +645,7 @@ static int vidioc_querycap(struct file *file, void *priv, struct v4l2_capability
 
 	strlcpy(cap->driver, "v4l2 loopback", sizeof(cap->driver));
 
-	if (card_label[devnr] != NULL) {
-		snprintf(cap->card, sizeof(cap->card), card_label[devnr]);
-	} else {
-		snprintf(cap->card, sizeof(cap->card), "Dummy video device (0x%04X)", devnr);
-	}
+	vidioc_fill_name(cap->card, sizeof(cap->card), devnr);
 
 	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:v4l2loopback-%03d", devnr);
 
@@ -1457,6 +1462,12 @@ static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)
 	b->type = type;
 	b->index = index;
 	dprintkrw("buffer type: %d (of %d with size=%ld)\n", b->memory, dev->buffers_number, dev->buffer_size);
+
+	/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'
+		https://github.com/umlaeute/v4l2loopback/issues/60 */
+	b->flags &= ~V4L2_BUF_FLAG_DONE;
+	b->flags |= V4L2_BUF_FLAG_QUEUED;
+
 	return 0;
 }
 
@@ -1503,9 +1514,19 @@ static int vidioc_qbuf(struct file *file, void *private_data, struct v4l2_buffer
 		return 0;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		dprintkrw("output QBUF pos: %d index: %d\n", dev->write_position, index);
-		do_gettimeofday(&b->buffer.timestamp);
+		if (buf->timestamp.tv_sec == 0 && buf->timestamp.tv_usec == 0)
+			do_gettimeofday(&b->buffer.timestamp);
+		else
+			b->buffer.timestamp = buf->timestamp;
+		b->buffer.bytesused = buf->bytesused;
 		set_done(b);
 		buffer_written(dev, b);
+
+		/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'
+			https://github.com/umlaeute/v4l2loopback/issues/60 */
+		buf->flags &= ~V4L2_BUF_FLAG_DONE;
+	        buf->flags |= V4L2_BUF_FLAG_QUEUED;
+
 		wake_up_all(&dev->read_event);
 		return 0;
 	default:
@@ -1837,6 +1858,7 @@ static int v4l2_loopback_close(struct file *file)
 	int iswriter=0;
 	MARK();
 
+
 	opener = file->private_data;
 	dev    = v4l2loopback_getdevice(file);
 
@@ -1863,6 +1885,7 @@ static ssize_t v4l2_loopback_read(struct file *file,
 	int read_index;
 	struct v4l2_loopback_opener *opener;
 	struct v4l2_loopback_device *dev;
+	struct v4l2_buffer *b;
 	MARK();
 
 	opener = file->private_data;
@@ -1873,8 +1896,10 @@ static ssize_t v4l2_loopback_read(struct file *file,
           return read_index;
 	if (count > dev->buffer_size)
 		count = dev->buffer_size;
-	if (copy_to_user((void *)buf, (void *)(dev->image +
-			dev->buffers[read_index].buffer.m.offset), count)) {
+	b = &dev->buffers[read_index].buffer;
+	if (count > b->bytesused)
+		count = b->bytesused;
+	if (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset), count)) {
 		printk(KERN_ERR
 			"v4l2-loopback: failed copy_from_user() in write buf\n");
 		return -EFAULT;
@@ -1917,6 +1942,7 @@ static ssize_t v4l2_loopback_write(struct file *file,
 		return -EFAULT;
 	}
 	do_gettimeofday(&b->timestamp);
+	b->bytesused = count;
 	b->sequence = dev->write_position;
 	buffer_written(dev, &dev->buffers[write_index]);
 	wake_up_all(&dev->read_event);
@@ -2045,11 +2071,10 @@ static int allocate_timeout_image(struct v4l2_loopback_device *dev)
 static void init_vdev(struct video_device *vdev, int nr)
 {
 	MARK();
-	snprintf(vdev->name, sizeof(vdev->name), "Loopback video device %X", nr);
+	vidioc_fill_name(vdev->name, sizeof(vdev->name), nr);
 
 #ifdef V4L2LOOPBACK_WITH_STD
 	vdev->tvnorms      = V4L2_STD_ALL;
-	vdev->current_norm = V4L2_STD_ALL;
 #endif /* V4L2LOOPBACK_WITH_STD */
 
 	vdev->vfl_type     = VFL_TYPE_GRABBER;
@@ -2322,7 +2347,7 @@ static void free_devices(void)
 	}
 }
 
-int __init init_module(void)
+static int __init v4l2loopback_init_module(void)
 {
 	int ret;
 	int i;
@@ -2398,7 +2423,7 @@ int __init init_module(void)
 	return 0;
 }
 
-void __exit cleanup_module(void)
+static void v4l2loopback_cleanup_module(void)
 {
 	MARK();
 	/* unregister the device -> it deletes /dev/video* */
@@ -2406,6 +2431,18 @@ void __exit cleanup_module(void)
 	dprintk("module removed\n");
 }
 
+#ifdef MODULE
+int __init init_module(void)
+{
+        return v4l2loopback_init_module();
+}
+void __exit cleanup_module(void) {
+        return v4l2loopback_cleanup_module();
+}
+#else
+late_initcall(v4l2loopback_init_module);
+#endif
+
 
 
 /*
diff --git a/v4l2loopback_formats.h b/v4l2loopback_formats.h
index fd926c5..998214e 100644
--- a/v4l2loopback_formats.h
+++ b/v4l2loopback_formats.h
@@ -271,9 +271,9 @@
      .fourcc   = V4L2_PIX_FMT_MPEG,
      .depth    = 32,
      .flags    = FORMAT_FLAGS_COMPRESSED,
+     },
 #endif /* V4L2_PIX_FMT_MPEG */
 #ifdef V4L2_PIX_FMT_H264
-     },
 {
    .name     = "H264 with start codes",
      .fourcc   = V4L2_PIX_FMT_H264,
