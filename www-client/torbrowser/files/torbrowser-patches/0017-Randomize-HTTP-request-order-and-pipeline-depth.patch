From c5b94226e50a5502ef7902e2d05874f36d678769 Mon Sep 17 00:00:00 2001
From: Mike Perry <mikeperry-git@torproject.org>
Date: Tue, 28 Aug 2012 18:08:27 -0700
Subject: [PATCH 17/19] Randomize HTTP request order and pipeline depth.

This is an experimental defense against
http://lorre.uni.lu/~andriy/papers/acmccs-wpes11-fingerprinting.pdf

See:
https://blog.torproject.org/blog/experimental-defense-website-traffic-fingerprinting

This defense has been improved since that blog post to additionally randomize
the order and concurrency of non-pipelined HTTP requests.

This patch is also different from the 10.x ESR patch, as the pipelining
code has changed. We may want to set network.http.pipelining.aggressive to get
similar behavior...

The good news is we now randomize SPDY request order as well as pipeline
request order (though SPDY is still disabled by default in TBB).
---
 netwerk/protocol/http/nsHttpConnectionMgr.cpp |   58 +++++++++++++++++++++++--
 netwerk/protocol/http/nsHttpConnectionMgr.h   |    3 +
 2 files changed, 57 insertions(+), 4 deletions(-)

diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index 0bfaf3b..d565532 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -20,6 +20,8 @@
 #include "prnetdb.h"
 #include "mozilla/Telemetry.h"
 
+#include <stdlib.h>
+
 using namespace mozilla;
 using namespace mozilla::net;
 
@@ -39,15 +41,39 @@ InsertTransactionSorted(nsTArray<nsHttpTransaction*> &pendingQ, nsHttpTransactio
     // insert into queue with smallest valued number first.  search in reverse
     // order under the assumption that many of the existing transactions will
     // have the same priority (usually 0).
+    PRInt32 begin = 0, end = -1;
+
+    if (pendingQ.IsEmpty()) {
+         pendingQ.InsertElementAt(0, trans);
+         return;
+    }
 
     for (PRInt32 i=pendingQ.Length()-1; i>=0; --i) {
         nsHttpTransaction *t = pendingQ[i];
-        if (trans->Priority() >= t->Priority()) {
-            pendingQ.InsertElementAt(i+1, trans);
-            return;
+        if (end == -1 && trans->Priority() >= t->Priority()) {
+            end = i+1;
+        } else if (trans->Priority() < t->Priority()) {
+            begin = i+1;
+            break;
         }
     }
-    pendingQ.InsertElementAt(0, trans);
+
+    if (end == -1) {
+         pendingQ.AppendElement(trans);
+         return;
+    }
+
+    // Choose random destination begin..end
+    PRInt32 count = 1+end - begin;
+
+    if (count == 0) count = 1; // shouldn't happen...
+
+    // FIXME: rand() is not crypto-secure.. but meh, this code will probably
+    // change like 2 dozen more times before merge, and rand() is probably 
+    // good enough for our purposes anyways.
+    pendingQ.InsertElementAt(begin + (rand()%count), trans);
+
+    // XXX Verify length, ordering inside a DEBUG ifdef??
 }
 
 //-----------------------------------------------------------------------------
@@ -70,6 +96,12 @@ nsHttpConnectionMgr::nsHttpConnectionMgr()
     mCT.Init();
     mAlternateProtocolHash.Init(16);
     mSpdyPreferredHash.Init();
+
+    nsresult rv;
+    mRandomGenerator = do_GetService("@mozilla.org/security/random-generator;1", &rv);
+    if (NS_FAILED(rv)) {
+        mRandomGenerator = nsnull;
+    }
 }
 
 nsHttpConnectionMgr::~nsHttpConnectionMgr()
@@ -1141,6 +1173,19 @@ nsHttpConnectionMgr::AtActiveConnectionLimit(nsConnectionEntry *ent, PRUint8 cap
         maxPersistConns = mMaxPersistConnsPerHost;
     }
 
+    // Fuzz maxConns for website fingerprinting attack
+    // We create a range of maxConns/5 up to 6*maxConns/5 
+    // because this function is called repeatedly, and we'll
+    // end up converging on the high side of concurrent connections
+    // after a short while. 
+    PRUint8 *bytes = nsnull;
+    nsresult rv = mRandomGenerator->GenerateRandomBytes(1, &bytes);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    bytes[0] = bytes[0] % (maxConns + 1);
+    maxConns = (maxConns/5) + bytes[0];
+    NS_Free(bytes);
+
     // use >= just to be safe
     bool result = (totalCount >= maxConns) || ( (caps & NS_HTTP_ALLOW_KEEPALIVE) &&
                                               (persistCount >= maxPersistConns) );
@@ -1307,6 +1352,11 @@ nsHttpConnectionMgr::AddToShortestPipeline(nsConnectionEntry *ent,
 
     maxdepth = PR_MIN(maxdepth, depthLimit);
 
+    if (maxdepth/2 > 1) { 
+      // This is a crazy hack to randomize pipeline depth a bit more..
+      maxdepth = 1 + maxdepth/2 + (rand() % (maxdepth/2));
+    }
+
     if (maxdepth < 2)
         return false;
 
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 9e65da0..07c93b1 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -22,6 +22,7 @@
 #include "nsIObserver.h"
 #include "nsITimer.h"
 #include "nsIX509Cert3.h"
+#include "nsIRandomGenerator.h"
 
 class nsHttpPipeline;
 
@@ -579,6 +580,8 @@ private:
     PRUint64 mTimeOfNextWakeUp;
     // Timer for next pruning of dead connections.
     nsCOMPtr<nsITimer> mTimer;
+    // Random number generator for reordering HTTP pipeline
+    nsCOMPtr<nsIRandomGenerator>             mRandomGenerator;
 
     // A 1s tick to call nsHttpConnection::ReadTimeoutTick on
     // active http/1 connections. Disabled when there are no
-- 
1.7.5.4

