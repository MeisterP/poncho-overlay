From 1777a19229cf111156aeae078344a27f34c953c3 Mon Sep 17 00:00:00 2001
From: Mike Perry <mikeperry-git@torproject.org>
Date: Fri, 20 Jul 2012 18:13:44 -0700
Subject: [PATCH 17/21] Randomize HTTP request order and pipeline depth.

This is an experimental defense against
http://lorre.uni.lu/~andriy/papers/acmccs-wpes11-fingerprinting.pdf

See:
https://blog.torproject.org/blog/experimental-defense-website-traffic-fingerprinting

This defense has been improved since that blog post to additionally randomize
the order and concurrency of non-pipelined HTTP requests.

This patch is also different from the 10.x ESR patch, as the pipelining
code has changed. We may want to set network.http.pipelining.aggressive to get
similar behavior...

The good news is we now randomize SPDY request order as well as pipeline
request order (though SPDY is still disabled by default in TBB).
---
 netwerk/protocol/http/nsHttpConnectionMgr.cpp |   58 +++++++++++++++++++++++--
 netwerk/protocol/http/nsHttpConnectionMgr.h   |    3 +
 2 files changed, 57 insertions(+), 4 deletions(-)

diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index 5336c7d..b94ee31 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -52,6 +52,8 @@
 #include "prnetdb.h"
 #include "mozilla/Telemetry.h"
 
+#include <stdlib.h>
+
 using namespace mozilla;
 
 // defined by the socket transport service while active
@@ -70,15 +72,39 @@ InsertTransactionSorted(nsTArray<nsHttpTransaction*> &pendingQ, nsHttpTransactio
     // insert into queue with smallest valued number first.  search in reverse
     // order under the assumption that many of the existing transactions will
     // have the same priority (usually 0).
+    PRInt32 begin = 0, end = -1;
+
+    if (pendingQ.IsEmpty()) {
+         pendingQ.InsertElementAt(0, trans);
+         return;
+    }
 
     for (PRInt32 i=pendingQ.Length()-1; i>=0; --i) {
         nsHttpTransaction *t = pendingQ[i];
-        if (trans->Priority() >= t->Priority()) {
-            pendingQ.InsertElementAt(i+1, trans);
-            return;
+        if (end == -1 && trans->Priority() >= t->Priority()) {
+            end = i+1;
+        } else if (trans->Priority() < t->Priority()) {
+            begin = i+1;
+            break;
         }
     }
-    pendingQ.InsertElementAt(0, trans);
+
+    if (end == -1) {
+         pendingQ.AppendElement(trans);
+         return;
+    }
+
+    // Choose random destination begin..end
+    PRInt32 count = 1+end - begin;
+
+    if (count == 0) count = 1; // shouldn't happen...
+
+    // FIXME: rand() is not crypto-secure.. but meh, this code will probably
+    // change like 2 dozen more times before merge, and rand() is probably 
+    // good enough for our purposes anyways.
+    pendingQ.InsertElementAt(begin + (rand()%count), trans);
+
+    // XXX Verify length, ordering inside a DEBUG ifdef??
 }
 
 //-----------------------------------------------------------------------------
@@ -101,6 +127,12 @@ nsHttpConnectionMgr::nsHttpConnectionMgr()
     mCT.Init();
     mAlternateProtocolHash.Init(16);
     mSpdyPreferredHash.Init();
+
+    nsresult rv;
+    mRandomGenerator = do_GetService("@mozilla.org/security/random-generator;1", &rv);
+    if (NS_FAILED(rv)) {
+        mRandomGenerator = nsnull;
+    }
 }
 
 nsHttpConnectionMgr::~nsHttpConnectionMgr()
@@ -1115,6 +1147,19 @@ nsHttpConnectionMgr::AtActiveConnectionLimit(nsConnectionEntry *ent, PRUint8 cap
         maxPersistConns = mMaxPersistConnsPerHost;
     }
 
+    // Fuzz maxConns for website fingerprinting attack
+    // We create a range of maxConns/5 up to 6*maxConns/5 
+    // because this function is called repeatedly, and we'll
+    // end up converging on the high side of concurrent connections
+    // after a short while. 
+    PRUint8 *bytes = nsnull;
+    nsresult rv = mRandomGenerator->GenerateRandomBytes(1, &bytes);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    bytes[0] = bytes[0] % (maxConns + 1);
+    maxConns = (maxConns/5) + bytes[0];
+    NS_Free(bytes);
+
     // use >= just to be safe
     bool result = (totalCount >= maxConns) || ( (caps & NS_HTTP_ALLOW_KEEPALIVE) &&
                                               (persistCount >= maxPersistConns) );
@@ -1250,6 +1295,11 @@ nsHttpConnectionMgr::AddToShortestPipeline(nsConnectionEntry *ent,
 
     maxdepth = PR_MIN(maxdepth, depthLimit);
 
+    if (maxdepth/2 > 1) { 
+      // This is a crazy hack to randomize pipeline depth a bit more..
+      maxdepth = 1 + maxdepth/2 + (rand() % (maxdepth/2));
+    }
+
     if (maxdepth < 2)
         return false;
 
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 9f36345..6e12015 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -54,6 +54,7 @@
 #include "nsIObserver.h"
 #include "nsITimer.h"
 #include "nsIX509Cert3.h"
+#include "nsIRandomGenerator.h"
 
 class nsHttpPipeline;
 
@@ -562,6 +563,8 @@ private:
     PRUint64 mTimeOfNextWakeUp;
     // Timer for next pruning of dead connections.
     nsCOMPtr<nsITimer> mTimer;
+    // Random number generator for reordering HTTP pipeline
+    nsCOMPtr<nsIRandomGenerator>             mRandomGenerator;
 
     // A 1s tick to call nsHttpConnection::ReadTimeoutTick on
     // active http/1 connections. Disabled when there are no
-- 
1.7.5.4

