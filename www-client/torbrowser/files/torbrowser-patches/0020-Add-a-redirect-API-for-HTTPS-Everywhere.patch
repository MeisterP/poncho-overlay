From 046d49340c963f140c618866a4ddd47cc75f576f Mon Sep 17 00:00:00 2001
From: Mike Perry <mikeperry-git@torproject.org>
Date: Thu, 26 Jul 2012 15:13:44 -0700
Subject: [PATCH 20/21] Add a redirect API for HTTPS-Everywhere.

---
 netwerk/protocol/http/HttpChannelChild.cpp         |   15 ++++-
 netwerk/protocol/http/HttpChannelChild.h           |    4 +
 netwerk/protocol/http/HttpChannelParent.cpp        |    4 +
 netwerk/protocol/http/HttpChannelParent.h          |    1 +
 netwerk/protocol/http/PHttpChannel.ipdl            |    1 +
 netwerk/protocol/http/nsHttpChannel.cpp            |   67 +++++++++++++++++---
 netwerk/protocol/http/nsHttpChannel.h              |   13 +++-
 netwerk/protocol/http/nsIHttpChannel.idl           |   12 ++++
 .../protocol/viewsource/nsViewSourceChannel.cpp    |   13 ++++-
 9 files changed, 118 insertions(+), 12 deletions(-)

diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
index 777dfb6..a563438 100644
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -1070,7 +1070,8 @@ HttpChannelChild::AsyncOpen(nsIStreamListener *listener, nsISupports *aContext)
   gNeckoChild->SendPHttpChannelConstructor(this, tabChild);
 
   SendAsyncOpen(IPC::URI(mURI), IPC::URI(mOriginalURI),
-                IPC::URI(mDocumentURI), IPC::URI(mReferrer), mLoadFlags,
+                IPC::URI(mDocumentURI), IPC::URI(mReferrer),
+                IPC::URI(mInternalRedirectURI), mLoadFlags,
                 mClientSetRequestHeaders, mRequestHead.Method(),
                 IPC::InputStream(mUploadStream), mUploadStreamHasHeaders,
                 mPriority, mRedirectionLimit, mAllowPipelining,
@@ -1114,6 +1115,18 @@ HttpChannelChild::SetupFallbackChannel(const char *aFallbackKey)
   DROP_DEAD();
 }
 
+NS_IMETHODIMP
+HttpChannelChild::RedirectTo(nsIURI *uri)
+{
+  // We can only redirect unopened channels
+  NS_ENSURE_TRUE(!mIPCOpen, NS_ERROR_ALREADY_OPENED);
+
+  // The redirect is stored internally for use in AsyncOpen
+  mInternalRedirectURI = uri;
+
+  return NS_OK;
+}
+
 // The next four _should_ be implemented, but we need to figure out how
 // to transfer the data from the chrome process first.
 
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
index 43617ef..f595c4d 100644
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -110,6 +110,9 @@ public:
   NS_IMETHOD GetLocalPort(PRInt32* port);
   NS_IMETHOD GetRemoteAddress(nsACString& addr);
   NS_IMETHOD GetRemotePort(PRInt32* port);
+
+  NS_IMETHOD RedirectTo(nsIURI *uri);
+
   // nsISupportsPriority
   NS_IMETHOD SetPriority(PRInt32 value);
   // nsIResumableChannel
@@ -160,6 +163,7 @@ private:
   RequestHeaderTuples mClientSetRequestHeaders;
   nsCOMPtr<nsIChildChannel> mRedirectChannelChild;
   nsCOMPtr<nsISupports> mSecurityInfo;
+  nsCOMPtr<nsIURI>      mInternalRedirectURI;
 
   bool mIsFromCache;
   bool mCacheEntryAvailable;
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
index 464cbe7..3ce94b8 100644
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -132,6 +132,7 @@ HttpChannelParent::RecvAsyncOpen(const IPC::URI&            aURI,
                                  const IPC::URI&            aOriginalURI,
                                  const IPC::URI&            aDocURI,
                                  const IPC::URI&            aReferrerURI,
+                                 const IPC::URI&            aInternalRedirectURI,
                                  const PRUint32&            loadFlags,
                                  const RequestHeaderTuples& requestHeaders,
                                  const nsHttpAtom&          requestMethod,
@@ -152,6 +153,7 @@ HttpChannelParent::RecvAsyncOpen(const IPC::URI&            aURI,
   nsCOMPtr<nsIURI> originalUri(aOriginalURI);
   nsCOMPtr<nsIURI> docUri(aDocURI);
   nsCOMPtr<nsIURI> referrerUri(aReferrerURI);
+  nsCOMPtr<nsIURI> internalRedirectUri(aInternalRedirectURI);
 
   nsCString uriSpec;
   uri->GetSpec(uriSpec);
@@ -179,6 +181,8 @@ HttpChannelParent::RecvAsyncOpen(const IPC::URI&            aURI,
     httpChan->SetDocumentURI(docUri);
   if (referrerUri)
     httpChan->SetReferrerInternal(referrerUri);
+  if (internalRedirectUri)
+    httpChan->SetInternalRedirectURI(internalRedirectUri);
   if (loadFlags != nsIRequest::LOAD_NORMAL)
     httpChan->SetLoadFlags(loadFlags);
 
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
index 6cfc3a6..a4b410a 100644
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -82,6 +82,7 @@ protected:
                              const IPC::URI&            originalUri,
                              const IPC::URI&            docUri,
                              const IPC::URI&            referrerUri,
+                             const IPC::URI&            internalRedirectUri,
                              const PRUint32&            loadFlags,
                              const RequestHeaderTuples& requestHeaders,
                              const nsHttpAtom&          requestMethod,
diff --git a/netwerk/protocol/http/PHttpChannel.ipdl b/netwerk/protocol/http/PHttpChannel.ipdl
index 252a6ee..23a912e 100644
--- a/netwerk/protocol/http/PHttpChannel.ipdl
+++ b/netwerk/protocol/http/PHttpChannel.ipdl
@@ -69,6 +69,7 @@ parent:
             URI                 original,
             URI                 doc,
             URI                 referrer,
+            URI                 internalRedirect,
             PRUint32            loadFlags,
             RequestHeaderTuples requestHeaders,
             nsHttpAtom          requestMethod,
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
index 23edc3c..c55fe4d 100644
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -1403,18 +1403,17 @@ nsHttpChannel::HandleAsyncRedirectChannelToHttps()
         return;
     }
 
-    nsresult rv = AsyncRedirectChannelToHttps();
+    nsresult rv = InternalRedirectChannelToHttps();
     if (NS_FAILED(rv))
-        ContinueAsyncRedirectChannelToHttps(rv);
+        ContinueInternalRedirectChannelToURI(rv);
 }
 
 nsresult
-nsHttpChannel::AsyncRedirectChannelToHttps()
+nsHttpChannel::InternalRedirectChannelToHttps()
 {
     nsresult rv = NS_OK;
     LOG(("nsHttpChannel::HandleAsyncRedirectChannelToHttps() [STS]\n"));
 
-    nsCOMPtr<nsIChannel> newChannel;
     nsCOMPtr<nsIURI> upgradedURI;
 
     rv = mURI->Clone(getter_AddRefs(upgradedURI));
@@ -1436,6 +1435,48 @@ nsHttpChannel::AsyncRedirectChannelToHttps()
     else
         upgradedURI->SetPort(oldPort);
 
+    return InternalRedirectChannelToURI(upgradedURI);
+}
+
+NS_IMETHODIMP
+nsHttpChannel::RedirectTo(nsIURI *newURI)
+{
+    // We can only redirect unopened channels
+    NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
+
+    // The redirect is stored internally for use in AsyncOpen
+    mInternalRedirectURI = newURI;
+
+    return NS_OK;
+}
+
+void
+nsHttpChannel::HandleAsyncInternalRedirect()
+{
+    NS_PRECONDITION(!mCallOnResume, "How did that happen?");
+    NS_PRECONDITION(mInternalRedirectURI, "How did that happen?");
+
+    if (mSuspendCount) {
+        LOG(("Waiting until resume to do async API redirect [this=%p]\n", this));
+        mCallOnResume = &nsHttpChannel::HandleAsyncInternalRedirect;
+        return;
+    }
+
+    nsresult rv = InternalRedirectChannelToURI(mInternalRedirectURI);
+    if (NS_FAILED(rv))
+        ContinueInternalRedirectChannelToURI(rv);
+
+    return;
+}
+
+nsresult
+nsHttpChannel::InternalRedirectChannelToURI(nsIURI *upgradedURI)
+{
+    nsresult rv = NS_OK;
+    LOG(("nsHttpChannel::InternalRedirectChannelToURI()\n"));
+
+    nsCOMPtr<nsIChannel> newChannel;
+
     nsCOMPtr<nsIIOService> ioService;
     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
     NS_ENSURE_SUCCESS(rv, rv);
@@ -1451,7 +1492,7 @@ nsHttpChannel::AsyncRedirectChannelToHttps()
     PRUint32 flags = nsIChannelEventSink::REDIRECT_PERMANENT;
 
     PushRedirectAsyncFunc(
-        &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
+        &nsHttpChannel::ContinueInternalRedirectChannelToURI);
     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
 
     if (NS_SUCCEEDED(rv))
@@ -1460,14 +1501,18 @@ nsHttpChannel::AsyncRedirectChannelToHttps()
     if (NS_FAILED(rv)) {
         AutoRedirectVetoNotifier notifier(this);
         PopRedirectAsyncFunc(
-            &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
+            &nsHttpChannel::ContinueInternalRedirectChannelToURI);
+
+        // If we've failed so far, cancel the current channel, too,
+        // as both HSTS and the redirectTo codepaths prefer
+        // request failure to insecurity.
+        Cancel(rv);
     }
 
     return rv;
 }
-
 nsresult
-nsHttpChannel::ContinueAsyncRedirectChannelToHttps(nsresult rv)
+nsHttpChannel::ContinueInternalRedirectChannelToURI(nsresult rv)
 {
     AutoRedirectVetoNotifier notifier(this);
 
@@ -3929,6 +3974,12 @@ nsHttpChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *context)
     if (mLoadGroup)
         mLoadGroup->AddRequest(this, nsnull);
 
+    // Check to see if we should redirect this channel elsewhere by 
+    // nsIHttpChannel.redirectTo API request
+    if (mInternalRedirectURI) {
+        return AsyncCall(&nsHttpChannel::HandleAsyncInternalRedirect);
+    }
+
     // Collect mAsyncOpenTime after we have called all obsrevers like
     // "http-on-modify-request" and load group observers that may set
     // mTimingEnabled flag.
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
index 5a61e21..d156c28 100644
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -138,6 +138,8 @@ public:
     // nsIChannel
     NS_IMETHOD GetSecurityInfo(nsISupports **aSecurityInfo);
     NS_IMETHOD AsyncOpen(nsIStreamListener *listener, nsISupports *aContext);
+    // nsIHttpChannel
+    NS_IMETHOD RedirectTo(nsIURI *newURI);
     // nsIHttpChannelInternal
     NS_IMETHOD SetupFallbackChannel(const char *aFallbackKey);
     // nsISupportsPriority
@@ -152,6 +154,9 @@ public: /* internal necko use only */
     void SetUploadStreamHasHeaders(bool hasHeaders) 
       { mUploadStreamHasHeaders = hasHeaders; }
 
+    void SetInternalRedirectURI(nsIURI *redirectTo) 
+      { mInternalRedirectURI = redirectTo; }
+
     nsresult SetReferrerInternal(nsIURI *referrer) {
         nsCAutoString spec;
         nsresult rv = referrer->GetAsciiSpec(spec);
@@ -190,11 +195,14 @@ private:
 
     // redirection specific methods
     void     HandleAsyncRedirect();
+    void     HandleAsyncInternalRedirect();
     nsresult ContinueHandleAsyncRedirect(nsresult);
     void     HandleAsyncNotModified();
     void     HandleAsyncFallback();
     nsresult ContinueHandleAsyncFallback(nsresult);
     nsresult PromptTempRedirect();
+    nsresult InternalRedirectChannelToURI(nsIURI *);
+
     virtual nsresult SetupReplacementChannel(nsIURI *, nsIChannel *,
                                              bool preserveMethod,
                                              bool forProxy);
@@ -256,8 +264,8 @@ private:
     bool     MustValidateBasedOnQueryUrl();
 
     void     HandleAsyncRedirectChannelToHttps();
-    nsresult AsyncRedirectChannelToHttps();
-    nsresult ContinueAsyncRedirectChannelToHttps(nsresult rv);
+    nsresult InternalRedirectChannelToHttps();
+    nsresult ContinueInternalRedirectChannelToURI(nsresult rv);
 
     /**
      * A function that takes care of reading STS headers and enforcing STS 
@@ -327,6 +335,7 @@ private:
     friend class AutoRedirectVetoNotifier;
     friend class HttpAsyncAborter<nsHttpChannel>;
     nsCOMPtr<nsIURI>                  mRedirectURI;
+    nsCOMPtr<nsIURI>                  mInternalRedirectURI;
     nsCOMPtr<nsIChannel>              mRedirectChannel;
     PRUint32                          mRedirectType;
 
diff --git a/netwerk/protocol/http/nsIHttpChannel.idl b/netwerk/protocol/http/nsIHttpChannel.idl
index 2d3f01a..39b2ee5 100644
--- a/netwerk/protocol/http/nsIHttpChannel.idl
+++ b/netwerk/protocol/http/nsIHttpChannel.idl
@@ -291,4 +291,16 @@ interface nsIHttpChannel : nsIChannel
      *         has been received (before onStartRequest).
      */
     boolean isNoCacheResponse();
+    
+    /**
+     * Instructs the channel to immediately redirect to a new destination.
+     * Can only be called on channels not yet opened.
+     * 
+     * This method provides no explicit conflict resolution. The last
+     * caller to call it wins.
+     *
+     * @throws NS_ERROR_ALREADY_OPENED if called after the channel
+     *         has been opened.
+     */ 
+    void redirectTo(in nsIURI aNewURI);
 };
diff --git a/netwerk/protocol/viewsource/nsViewSourceChannel.cpp b/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
index 919c3f7..e286b8f 100644
--- a/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
+++ b/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
@@ -703,4 +703,15 @@ nsViewSourceChannel::IsNoCacheResponse(bool *_retval)
 {
     return !mHttpChannel ? NS_ERROR_NULL_POINTER :
         mHttpChannel->IsNoCacheResponse(_retval);
-} 
+}
+
+// XXX: Is this the right thing to do here? Or should we have
+// made an nsIHTTPChannelRedirect that only nsHttpChannel implements?
+// Also, will this mean that some ViewSource requests may be non-https?
+// Or will the mHttpChannel take care of that for us?
+NS_IMETHODIMP
+nsViewSourceChannel::RedirectTo(nsIURI *uri)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
-- 
1.7.5.4

